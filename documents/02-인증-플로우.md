# 인증 플로우 상세 가이드

## 인증 방식 개요

### 지원하는 인증 방식
1. **로컬 인증**: 이메일/비밀번호 기반 로그인
2. **Google 소셜 로그인**: OAuth2 팝업 기반 인증
3. **JWT 토큰 기반**: Access Token + Refresh Token 조합

## 로컬 인증 플로우

### 1. 사용자 등록 (POST /api/auth/register)
```
클라이언트 → 게이트웨이 → Keycloak → User Service → 게이트웨이 → 클라이언트

1. 클라이언트가 사용자 정보 전송 (이메일, 비밀번호, 이름 등)
2. 게이트웨이에서 입력 검증
3. Keycloak에 사용자 계정 생성
4. User Service에 사용자 프로필 생성
5. JWT 토큰 발급 및 반환
```

**요청 예시:**
```json
POST /api/auth/register
{
  "email": "user@example.com",
  "password": "password123",
  "name": "홍길동",
  "phone": "010-1234-5678"
}
```

**응답 예시:**
```json
{
  "success": true,
  "message": "회원가입이 완료되었습니다",
  "accessToken": "eyJhbGciOiJSUzI1NiIs...",
  "refreshToken": "eyJhbGciOiJIUzI1NiIs...",
  "expiresIn": 300,
  "user": {
    "id": "c503fee4-68cc-4f0e-aee5-13efa633094e",
    "email": "user@example.com",
    "name": "홍길동"
  }
}
```

### 2. 로그인 (POST /api/auth/login)
```
클라이언트 → 게이트웨이 → Keycloak → 게이트웨이 → 클라이언트

1. 클라이언트가 이메일/비밀번호 전송
2. 게이트웨이가 Keycloak Token Endpoint로 인증 요청
3. Keycloak이 자격증명 검증 후 JWT 토큰 발급
4. 게이트웨이가 토큰과 사용자 정보 반환
```

**요청 예시:**
```json
POST /api/auth/login
{
  "email": "user@example.com",
  "password": "password123"
}
```

## Google 소셜 로그인 플로우

### 1. 소셜 로그인 시작 (GET /api/auth/oauth2/authorization/google)
```
클라이언트 → 게이트웨이 → Google OAuth → 게이트웨이 → 클라이언트

1. 클라이언트가 팝업창으로 Google OAuth URL 요청
2. 사용자가 Google 계정으로 인증
3. Google이 authorization code와 함께 콜백
4. 게이트웨이가 사용자 정보 조회 및 처리
5. Keycloak 계정 생성/업데이트
6. User Service에 프로필 동기화
7. JWT 토큰 발급 및 팝업으로 전달
```

### 2. 소셜 로그인 콜백 처리
```java
// OAuth2UserService에서 Google 사용자 정보 처리
@Override
public Mono<OAuth2User> loadUser(OAuth2UserRequest userRequest) {
    // Google에서 사용자 정보 조회
    // Keycloak에 사용자 생성/업데이트
    // User Service에 프로필 동기화
    // Custom OAuth2User 객체 반환
}
```

## JWT 토큰 구조

### Access Token 클레임
```json
{
  "iss": "http://keycloak:8080/realms/sangsang-plus",
  "sub": "c503fee4-68cc-4f0e-aee5-13efa633094e",
  "email": "user@example.com",
  "preferred_username": "user@example.com",
  "realm_access": {
    "roles": ["offline_access", "default-roles-sangsang-plus", "uma_authorization"]
  },
  "provider": "LOCAL",
  "loginCount": 1,
  "lastLoginAt": "2025-08-04T06:25:26",
  "userId": "c503fee4-68cc-4f0e-aee5-13efa633094e",
  "exp": 1723012826,
  "iat": 1723012526
}
```

### 토큰 갱신 플로우 (POST /api/auth/refresh)
```
클라이언트 → 게이트웨이 → Keycloak → 게이트웨이 → 클라이언트

1. 클라이언트가 refresh_token으로 갱신 요청
2. 게이트웨이가 Keycloak Token Endpoint로 refresh 요청
3. Keycloak이 새 access_token 발급 (refresh_token은 선택적 갱신)
4. 게이트웨이가 새 토큰 반환 (refresh_token이 null이면 기존 것 유지)
```

**요청 예시:**
```json
POST /api/auth/refresh
{
  "refresh_token": "eyJhbGciOiJIUzI1NiIs..."
}
```

**응답 예시:**
```json
{
  "success": true,
  "message": "토큰 갱신 성공",
  "accessToken": "eyJhbGciOiJSUzI1NiIs...",
  "refreshToken": "eyJhbGciOiJIUzI1NiIs...", // null일 수 있음 (기존 토큰 유지)
  "expiresIn": 300
}
```

## 로그아웃 플로우 (POST /api/auth/logout)

### 안전한 로그아웃 처리
```
클라이언트 → 게이트웨이 → Keycloak → 게이트웨이 → 클라이언트

1. 클라이언트가 refresh_token으로 로그아웃 요청
2. 게이트웨이가 Keycloak Logout Endpoint 호출
3. Keycloak에서 세션 무효화
4. 클라이언트 측 토큰 정리 안내
```

**중요 특징:**
- refresh_token이 없어도 로그아웃 성공 처리
- Keycloak 로그아웃 실패해도 클라이언트 로그아웃은 성공
- @PreAuthorize 없이 인증 상태와 관계없이 처리 가능

## 헤더 전파 메커니즘

### JWT 필터를 통한 자동 헤더 추가 (외부 라우트)
```java
// JwtAuthGatewayFilterFactory에서 자동 처리
ServerHttpRequest modifiedRequest = request.mutate()
    .header("X-User-Id", userId)           // UserService 조회 결과
    .header("X-User-Email", email)         // JWT email 클레임
    .header("X-User-Role", roles)          // JWT roles 배열
    .header("X-User-Provider", provider)   // LOCAL/GOOGLE
    .header("X-User-LoginCount", loginCount)
    .header("X-User-LastLoginAt", lastLoginAt)
    .build();
```

### 수동 헤더 추가 (내부 컨트롤러)
```java
// UserService에서 수동 헤더 추가
HttpHeaders headers = new HttpHeaders();
headers.set("X-User-Id", userIdForHeader);
headers.set("X-User-Email", userEmail);

HttpEntity<Map<String, String>> entity = new HttpEntity<>(updateData, headers);
restTemplate.exchange(url, HttpMethod.PUT, entity, Void.class);
```

## 에러 처리 전략

### 인증 실패 시나리오
1. **Invalid Token**: HTTP 401, 재로그인 필요
2. **Expired Token**: HTTP 401, refresh token으로 갱신 시도
3. **Invalid Refresh Token**: HTTP 401, 완전 재로그인 필요
4. **Keycloak Unavailable**: HTTP 503, 서비스 일시 중단
5. **Network Error**: HTTP 503, 연결 재시도 권장

### 보안 고려사항
- Access Token: 5분 짧은 수명으로 탈취 위험 최소화
- Refresh Token: 30일 장기간, 안전한 저장소에 보관 필수
- Token Rotation: 매번 새 refresh token 발급으로 재사용 방지
- HTTPS Only: 모든 인증 관련 통신은 HTTPS 필수